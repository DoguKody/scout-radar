"""
YouTube client for ScoutRadar.
@dogu - 2025-04-21
"""

import os
from googleapiclient.discovery import build
from dotenv import load_dotenv
import json

def get_youtube_service():
    try:
        load_dotenv()
        YOUTUBE_API_KEY = os.getenv("YOUTUBE_API_KEY")
        if not YOUTUBE_API_KEY:
            raise ValueError("‚ùå Missing YOUTUBE_API_KEY environment variable.")
        youtube = build("youtube", "v3", developerKey=YOUTUBE_API_KEY)
        return youtube  
    except Exception as e:
        print(f"‚ùå Failed to initialize YouTube API client: {e}")
        return None
    
def search_artist_channel(youtube, artist_name, max_results=10):
    """
    Searches for a YouTube channel matching an artist name using two strategies:

    1. Channel Search: Directly looks up channels by name (may miss stylized names like 'insyt.').
    2. Video Search: Finds videos mentioning the artist, then extracts their channel IDs (captures Topic and smaller channels).

    Each result is tracked with how it was found:
    - 'channel_search' count
    - 'video_search' count

    Returns a list of unique candidate channel IDs.
        """
    try:
        print(f"üîé Primary search for channels matching: {artist_name}")
        channel_ids = set()
        results = {}

        # 1st search by channel name
        channel_response = youtube.search().list(
            q=artist_name,
            type="channel",
            part="snippet",
            maxResults=max_results
        ).execute()

        for item in channel_response.get("items", []):
            cid = item['snippet']['channelId']
            title = item['snippet']['title']
            if cid not in results:
                results[cid] = {
                    "title": title,
                    "source_count": {"channel_search": 1, "video_search": 0}
                }
            else:
                results[cid]["source_count"]["channel_search"] += 1

        print(f"‚úÖ Found {len(channel_ids)} unique channels by name.")

        # 2nd search by video to catch topic channels
        print(f"Secondary search via videos mentioning artist: {artist_name}")
        video_response = youtube.search().list(
            q=artist_name,
            type="video",
            part="snippet",
            maxResults=max_results
        ).execute()

        for item in video_response.get("items", []):
            cid = item['snippet']['channelId']
            title = item['snippet']['channelTitle']
            if cid not in results:
                results[cid] = {
                "title": title,
                "source_count": {"channel_search": 0, "video_search": 1}
                }
            else:
                results[cid]["source_count"]["video_search"] += 1

        #print("üìä Combined channel matches:")
        for i, (cid, meta) in enumerate(results.items(), 1):
            cs = meta['source_count']['channel_search']
            vs = meta['source_count']['video_search']
            #print(f"{i}. {meta['title']} ‚Üí {cid} [channel_search: {cs}, video_search: {vs}]")

        return results

    except Exception as e:
        print(f"‚ùå Error during artist search: {e}")
        return []
    
def select_best_channel(results_dict, artist_name):
    """
    Selects the best matching YouTube channel for a given artist based on heuristics.

    Heuristics:
    1. Ignore any channels with ' - Topic' in the title (auto-generated by YouTube).
    2. Match the channel title exactly to artist_name (case-insensitive).
    3. If multiple exact matches exist, return the one with the highest 'video_search' count.
    4. Return None if no exact match is found (can handle fallback separately).
    """
    artist_name_clean = artist_name.strip().lower()
    exact_matches = {}

    for cid, data in results_dict.items():
        title = data['title'].strip().lower()
        if " - topic" in title:
            continue  
        if title == artist_name_clean:
            exact_matches[cid] = data

    if not exact_matches:
        return None  #  no clean match

    # exact match with highest video_search count
    best_cid = max(
        exact_matches.items(),
        key=lambda item: item[1]['source_count']['video_search']
    )[0]

    return best_cid

# helper for `get_channel_details`
def fetch_all_video_ids(youtube, channel_id, max_results_per_page=50):
    """
    Fetches all video IDs uploaded by a given YouTube channel using pagination.
    
    Parameters:
        youtube (Resource): The authenticated YouTube API client.
        channel_id (str): The ID of the YouTube channel.
        max_results_per_page (int): Number of results per API call (default 50, max allowed by API).

    Returns:
        List[str]: A list of all video IDs uploaded by the channel.
    """
    video_ids = []
    next_page_token = None

    try:
        while True:
            search_response = youtube.search().list(
                channelId=channel_id,
                part="id",
                maxResults=max_results_per_page,
                pageToken=next_page_token,
                type="video",
                order="date"
            ).execute()

            for item in search_response.get("items", []):
                if item["id"]["kind"] == "youtube#video":
                    video_ids.append(item["id"]["videoId"])

            next_page_token = search_response.get("nextPageToken")
            if not next_page_token:
                break

    except Exception as e:
        print(f"‚ùå Error fetching video IDs: {e}")

    return video_ids

# helper for `get_channel_details`
def fetch_video_stats_batch(youtube, video_ids):
    """
    Fetches statistics (viewCount, likeCount, commentCount) for a batch of YouTube video IDs.

    Parameters:
        youtube (Resource): The authenticated YouTube API client.
        video_ids (List[str]): List of video IDs to query (max 50 per call).

    Returns:
        Dict[str, Dict]: A dictionary where keys are video IDs and values are their statistics.
    """
    stats = {}

    try:
        for i in range(0, len(video_ids), 50):  # API limit is 50 videos per request
            chunk = video_ids[i:i + 50]
            response = youtube.videos().list(
                part="statistics",
                id=",".join(chunk)
            ).execute()

            for item in response.get("items", []):
                vid = item["id"]
                stats[vid] = item.get("statistics", {})

    except Exception as e:
        print(f"‚ùå Error fetching video statistics: {e}")

    return stats

# helper for `get_channel_details`
def summarize_video_stats(stats_dict):
    """
    Aggregates total views, likes, and comments from a dictionary of per-video statistics.

    Parameters:
        stats_dict (Dict[str, Dict]): Dictionary with video IDs as keys and their stats as values.

    Returns:
        Dict[str, int]: Cumulative totals for viewCount, likeCount, and commentCount.
    """
    total_views = 0
    total_likes = 0
    total_comments = 0

    for stats in stats_dict.values():
        total_views += int(stats.get("viewCount", 0))
        total_likes += int(stats.get("likeCount", 0))
        total_comments += int(stats.get("commentCount", 0))

    return {
        "total_views": total_views,
        "total_likes": total_likes,
        "total_comments": total_comments
    }


def get_channel_details(youtube, channel_id):
    """
    Fetches metadata and cumulative statistics for a given YouTube channel.

    Parameters:
        youtube (Resource): Authenticated YouTube Data API client.
        channel_id (str): The ID of the channel to retrieve information for.

    Returns:
        str: A JSON string containing channel metadata and aggregate video stats.
    """
    try:
        # channel metadata
        response = youtube.channels().list(
            part="snippet,statistics",
            id=channel_id
        ).execute()

        if not response["items"]:
            return json.dumps({"error": "Channel not found"})

        info = response["items"][0]

        # base info
        base_data = {
            "id": info["id"],
            "title": info["snippet"]["title"],
            "description": info["snippet"].get("description", ""),
            "customUrl": info["snippet"].get("customUrl", ""),
            "publishedAt": info["snippet"]["publishedAt"],
            #"viewCount": info["statistics"].get("viewCount", "0"),
            "subscriberCount": info["statistics"].get("subscriberCount", "0"),
            "hiddenSubscriberCount": info["statistics"].get("hiddenSubscriberCount", False),
            "contentCount": info["statistics"].get("videoCount", "0")
        }

        # summarize video metrics
        video_ids = fetch_all_video_ids(youtube, channel_id)
        stats = fetch_video_stats_batch(youtube, video_ids)
        totals = summarize_video_stats(stats)

        return json.dumps({
            **base_data,
            **totals
        }, indent=2)

    except Exception as e:
        return json.dumps({"error": str(e)})


# -----------TESTING-----------
if __name__ == "__main__":
    artist_name = "Lelo"  
    youtube_key = get_youtube_service()
    results_dict = search_artist_channel(youtube_key, artist_name)
    best_channel = select_best_channel(results_dict, artist_name)
    channel_data = get_channel_details(youtube_key, best_channel)

    print(channel_data)

    '''
    if best_channel:
        meta = results_dict[best_channel]
        print(f"\nFinal channel ID: {best_channel}")
        print(f"Channel title: {meta['title']}")
        print(f"Counts ‚Äî Channel search: {meta['source_count']['channel_search']}, Video search: {meta['source_count']['video_search']}")
    else:
        print("No suitable channel found.")
    '''
    
#---------NOTES---------
# Here are some edge cases I am likely to deal with:

# 1. Topic Channel Ranks Higher Than Official Channel
#    - Issue: Artist's auto-generated "Topic" channel may rank above their actual page.
#    - Example: ‚ÄúSuperheaven - Topic‚Äù shows before ‚ÄúSuperheaven‚Äù.
#    - Heuristic: Deprioritize channels with no custom URL and title ending in " - Topic".

# 2. Duplicate or Ambiguous Artist Names
#    - Issue: Multiple channels may exist for a generic name like ‚ÄúHerne‚Äù.
#    - Heuristic: Use video search fallback (e.g., "Herne official music video") and match uploader channels.

# 3. Legitimate Artist Channels With Low Visibility
#    - Issue: Underground artists might lack subscribers, branding, or even a handle.
#    - Heuristic: Favor channels uploading full music videos or albums over unrelated promo/media snippets.

# 4. Artist Releases Through Labels or Collectives
#    - Issue: Artist content is hosted under label/group accounts (e.g., Stones Throw, Lyrical Lemonade).
#    - Heuristic: Detect label patterns (shared uploads across artists) and tag as collective-hosted.

# 5. Artists Maintain Multiple Active Channels
#    - Issue: Some split content across "Official", "Vlogs", "Live", etc.
#    - Heuristic: Flag duplicate titles and compare engagement (upload count, recent activity, view stats).
